# Introduction to SQL

Structured Query Language (SQL) is a standard language for managing and manipulating relational databases. It is used to perform tasks such as retrieving data, updating data, and managing database schemas.

## Types of SQL Commands

SQL commands are broadly categorized into several types based on their functionality.

### 1. Data Definition Language (DDL)

DDL commands are used to define and manage the database structure or schema. These commands are responsible for creating, altering, and deleting database objects.

*   **`CREATE`**: Used to create new database objects like tables, views, indexes, and databases.
    ```sql
    CREATE TABLE employees (
        id INT PRIMARY KEY,
        name VARCHAR(100)
    );
    ```

*   **`ALTER`**: Used to modify the structure of an existing database object, such as adding or dropping columns in a table.
    ```sql
    ALTER TABLE employees
    ADD COLUMN email VARCHAR(100);
    ```

*   **`DROP`**: Used to delete existing database objects.
    ```sql
    DROP TABLE employees;
    ```

*   **`TRUNCATE`**: Used to remove all records from a table, but the table structure remains. It is faster than `DELETE` for emptying a table.
    ```sql
    TRUNCATE TABLE employees;
    ```

### 2. Data Manipulation Language (DML)

DML commands are used for managing data within the database objects.

*   **`INSERT`**: Used to add new rows of data into a table.
    ```sql
    INSERT INTO employees (id, name) VALUES (1, 'John Doe');
    ```

*   **`UPDATE`**: Used to modify existing records in a table.
    ```sql
    UPDATE employees
    SET name = 'Jane Doe'
    WHERE id = 1;
    ```

*   **`DELETE`**: Used to remove existing records from a table.
    ```sql
    DELETE FROM employees WHERE id = 1;
    ```

### 3. Data Query Language (DQL)

DQL is used to retrieve data from the database. The primary command for DQL is `SELECT`.

*   **`SELECT`**: Used to query the database and retrieve data that matches criteria that you specify.
    ```sql
    SELECT name, email FROM employees WHERE id = 1;
    ```

### 4. Data Control Language (DCL)

DCL commands are used to manage user access and permissions to the database.

*   **`GRANT`**: Used to give a user access privileges to the database.
    ```sql
    GRANT SELECT, UPDATE ON employees TO user_jane;
    ```

*   **`REVOKE`**: Used to take back permissions from a user.
    ```sql
    REVOKE SELECT, UPDATE ON employees FROM user_jane;
    ```

### 5. Transaction Control Language (TCL)

TCL commands are used to manage transactions in the database. Transactions are sequences of operations performed as a single logical unit of work.

*   **`COMMIT`**: Saves all the transactions to the database since the last `COMMIT` or `ROLLBACK`.
    ```sql
    COMMIT;
    ```

*   **`ROLLBACK`**: Undoes transactions that have not already been saved to the database.
    ```sql
    ROLLBACK;
    ```

*   **`SAVEPOINT`**: Sets a point within a transaction to which you can later roll back.
    ```sql
    SAVEPOINT my_savepoint;
    ```

<br></br>

# Logical Query Processing Order

Understanding the logical order of execution for a SQL query is crucial for writing and optimizing complex queries. It's important to note that this is the **logical processing order**, not necessarily the exact physical order a database might use, but it defines how the clauses interact with each other.

Here is the logical execution order of a `SELECT` statement:

1.  **`FROM`**: The database first identifies the tables involved in the query.

2.  **`JOIN`s**: It performs any `JOIN` operations to combine identified tables into a single, large virtual set of rows.

3.  **`WHERE`**: The `WHERE` clause is applied to this virtual set of rows, filtering out any rows that do not meet the specified conditions. This happens *before* any grouping.

4.  **`GROUP BY`**: The remaining rows are grouped into smaller sets based on the unique values in the columns specified in the `GROUP BY` clause. After this step, any subsequent clause can only operate on the grouped data, not the original individual rows.

5.  **`HAVING`**: The `HAVING` clause filters these newly created *groups*. It's similar to `WHERE`, but it operates on the results of aggregate functions (like `COUNT()`, `SUM()`, `AVG()`) applied to the groups, whereas `WHERE` operates on individual rows.

6.  **`SELECT`**: The `SELECT` clause processes the final set of rows (or groups). It calculates any expressions, applies window functions (like `ROW_NUMBER()`), and selects the final columns that will be returned.

7.  **`DISTINCT`**: If `DISTINCT` is present, duplicate rows are removed from the result set generated by the `SELECT` clause.

8.  **`ORDER BY`**: The rows in the final result set are sorted according to the columns and direction specified in the `ORDER BY` clause.

9.  **`LIMIT` / `OFFSET`** (or `TOP` / `FETCH`): Finally, if specified, the database discards all rows except for the number specified in the `LIMIT` clause, after skipping the number of rows specified in the `OFFSET` clause. This is the very last step.

<br></br>

# SQL Query Optimization

[Secret To Optimizing SQL Queries - Understand The SQL Execution Order](https://www.youtube.com/watch?v=BHwzDmr6d7s)

Query optimization is the process of improving the performance of SQL queries to ensure they run as efficiently as possible. An optimized query minimizes resource usage (like CPU time and memory) and returns results faster.

## Key Optimization Techniques

### 1. Use Indexes Effectively
Indexes are the most powerful tool for speeding up data retrieval. They allow the database to find rows with specific column values much more quickly than scanning the entire table.

*   **Best Practices:**
    *   Create indexes on columns that are frequently used in `WHERE` clauses, `JOIN` conditions, and `ORDER BY` clauses.
    *   Remember that `PRIMARY KEY` and `UNIQUE` constraints automatically create indexes.
    *   Avoid over-indexing. While indexes speed up reads (`SELECT`), they slow down writes (`INSERT`, `UPDATE`, `DELETE`) because the index must also be updated.

### 2. Write Efficient `WHERE` Clauses
The `WHERE` clause filters data. The more specific it is, the fewer rows the database has to process in later stages of the query.

*   **Best Practices:**
    *   **Filter Early:** Apply the most restrictive conditions first.
    *   **Avoid Functions on Indexed Columns:** Applying a function to a column in the `WHERE` clause often prevents the database from using an index on that column.
        ```sql
        -- BAD: Prevents index usage on order_date
        SELECT * FROM orders WHERE YEAR(order_date) = 2023;

        -- GOOD: Allows index usage on order_date
        SELECT * FROM orders WHERE order_date >= '2023-01-01' AND order_date < '2024-01-01';
        ```

### 3. Avoid `SELECT *`
Only select the columns you actually need.

*   **Why?**
    *   **Reduces Data Transfer:** Transferring unnecessary data from the database to your application consumes network bandwidth and memory.
    *   **Improves Index Usage:** In some cases, if you only select indexed columns, the database can answer the query from the index alone (a "covering index") without ever having to read the table data, which is much faster.

### 4. Use `JOIN`s Wisely
`JOIN` operations can be expensive.

*   **Best Practices:**
    *   Ensure that the columns used in `JOIN` conditions (`ON` clause) are indexed on both tables.
    *   Prefer `INNER JOIN` over `OUTER JOIN` (`LEFT JOIN`, `RIGHT JOIN`) when possible, as inner joins are generally more performant because they deal with a smaller result set.

### 5. Use `LIMIT` to Restrict Results
If you only need a certain number of rows, use the `LIMIT` clause (or `TOP` / `FETCH FIRST` in other SQL dialects) to tell the database to stop working once it has found the required number of rows. This is especially powerful when combined with `ORDER BY`.

```sql
-- Efficiently gets the 10 most recent orders
SELECT order_id, order_date
FROM orders
ORDER BY order_date DESC
LIMIT 10;
```

### 6. Understand the `EXPLAIN` Plan
All modern databases provide a tool to analyze how a query will be executed. The `EXPLAIN` command shows the "query plan" or "execution plan," which is the sequence of steps the database will take to run your query.

*   **How to Use It:**
    Let's consider a more complex query involving `JOIN`, `WHERE`, `ORDER BY`, and `LIMIT`.
    Assume `employees` table has `employee_id` (PK), `employee_name`, `department_id` (FK), `salary`.
    Assume `departments` table has `department_id` (PK), `department_name`.

    ```sql
    EXPLAIN SELECT
        e.employee_name,
        e.salary
    FROM
        employees e
    JOIN
        departments d ON e.department_id = d.department_id
    WHERE
        d.department_name = 'Sales'
    ORDER BY
        e.salary DESC
    LIMIT 5;
    ```

    **Example Output (Simplified - PostgreSQL-like):**
    *(Note: The exact output format and details vary significantly between database systems like PostgreSQL, MySQL, SQL Server, etc. This is a simplified representation.)*

    ```
                                             QUERY PLAN
    ---------------------------------------------------------------------------------------------
     Limit  (cost=10.00..10.05 rows=5 width=36)
       ->  Sort  (cost=10.00..10.10 rows=100 width=36)
             Sort Key: e.salary DESC
             ->  Hash Join  (cost=2.00..8.00 rows=100 width=36)
                   Hash Cond: (e.department_id = d.department_id)
                   ->  Index Scan using idx_employees_salary on employees e  (cost=0.50..5.00 rows=1000 width=32)
                   ->  Hash
                         ->  Index Scan using idx_departments_name on departments d  (cost=0.20..2.00 rows=1 width=8)
                               Index Cond: (department_name = 'Sales'::text)
    ```

    **What to Look For in the Output:**
    *   **`Limit`:** The final step to restrict the number of rows.
    *   **`Sort`:** Indicates an explicit sorting operation. If `Sort Key` matches an index, it might be an "Index Scan" or "Bitmap Index Scan" instead of a separate sort step, which is more efficient.
    *   **`Hash Join` / `Nested Loop Join` / `Merge Join`:** These are different algorithms the database uses to combine data from two tables. The choice depends on factors like table size, indexes, and available memory.
    *   **`Index Scan`:** The database is using an index to quickly find relevant rows. This is generally very efficient.
    *   **`Seq Scan` (Sequential Scan):** This indicates a full table scan, meaning the database read every row in a table. If this occurs on a large table for a filtered query, it often suggests a missing or unused index.
    *   **`Filter` / `Index Cond`:** Shows the conditions applied to filter rows. `Index Cond` means the condition was applied directly by the index.
    *   **`cost`:** An estimated cost of the operation (lower is generally better, but compare relative costs within a plan).
    *   **`rows`:** An estimated number of rows processed or returned by that step.
    *   **`width`:** An estimated average width of the rows.

Learning to read an `EXPLAIN` plan is a crucial skill for advanced query optimization.